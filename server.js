// server.js

// --- 1. Load Environment Variables ---
// IMPORTANT: This line MUST be at the very top to load variables from your .env file
require('dotenv').config(); 

// --- 2. Core Module Imports ---
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');

// --- 3. Database & Security Module Imports ---
// CHANGE: Imported mysql2 for MySQL connectivity and bcryptjs for password hashing.
const mysql = require('mysql2/promise'); // MySQL client library (uses promises for async/await)
const bcrypt = require('bcryptjs');     // For securely hashing and comparing passwords
// const jwt = require('jsonwebtoken'); // You'll need this when implementing JWT tokens for authentication

// --- 4. Initialize Express App ---
const app = express();
const PORT = process.env.PORT || 3000; // Use port from .env or default to 3000

// --- 5. MySQL Connection Pool Configuration ---
// CHANGE: Replaced direct connection with a connection pool for better performance and reliability.
// Uses environment variables from .env for sensitive credentials.
const pool = mysql.createPool({
    host: process.env.DB_HOST,      // e.g., 'localhost' or '127.0.0.1'
    user: process.env.DB_USER,      // e.g., 'root'
    password: process.env.DB_PASSWORD, // This should be empty string '' if your root has no password
    database: process.env.DB_NAME,
    port: 4000,
     ssl: {
        rejectUnauthorized: true
    },// e.g., 'doctor_app'
    waitForConnections: true,       // If true, waits for connection to become available if pool is exhausted
    connectionLimit: 10,            // Maximum number of connections in the pool
    queueLimit: 0                   // Unlimited number of connection requests can be queued
});

// --- 6. Test Database Connection ---
// Attempts to get a connection from the pool to verify database access on server startup.
pool.getConnection()
    .then(connection => {
        console.log('✅ MySQL connected successfully!');
        connection.release(); // Release the connection back to the pool immediately
    })
    .catch(err => {
        console.error('❌ MySQL connection error:', err.message);
        // If the database connection fails, it's critical. Exit the application.
        process.exit(1); 
    });

// --- 7. Middleware Setup ---
app.use(bodyParser.json()); // To parse JSON request bodies
app.use(cors());            // Enable CORS for all routes (allows frontend to make requests)
// Serves static files (HTML, CSS, JS, images) from the current directory (your project root)
app.use(express.static(__dirname)); 

// REMOVED: In-memory "database" variables are removed as data is now stored in MySQL.
// let appointments = []; 
// let nextAppointmentId = 1;

// --- 8. API Endpoints ---

// Contact Form Endpoint
app.post('/api/contact', async (req, res) => {
    const { name, email, subject, message } = req.body;

    // Basic validation
    if (!name || !email || !subject || !message) {
        return res.status(400).json({ message: 'All fields are required.' });
    }

    try {
        // In a real app, you'd save this to a database and/or send an email
        // For demo, we'll just return success
        res.status(200).json({ 
            message: 'Message sent successfully! We will get back to you soon.',
            contact: { name, email, subject, message }
        });
    } catch (error) {
        console.error('Contact form error:', error);
        res.status(500).json({ message: 'Server error while processing your message.' });
    }
});

// 1. Book Appointment
// CHANGE: This endpoint now inserts appointment data into the 'appointments' table in MySQL.
app.post('/api/book-appointment', async (req, res) => { // Added 'async' as we're using 'await'
    const { fullName, email, phone, date, time, message } = req.body;

    // Basic server-side validation
    if (!fullName || !email || !date || !time) {
        return res.status(400).json({ message: 'Full Name, Email, Date, and Time are required.' });
    }

    try {
        // Execute an SQL INSERT statement to add a new appointment
        const [result] = await pool.execute(
            'INSERT INTO appointments (fullName, email, phone, date, time, message, status, createdAt) VALUES (?, ?, ?, ?, ?, ?, ?, NOW())',
            // Parameters for the SQL query. 'NOW()' is a MySQL function for current timestamp.
            [fullName, email, phone || '', date, time, message || '', 'Pending'] 
        );

        // Construct the new appointment object to send back in the response,
        // including the ID generated by MySQL (result.insertId).
        const newAppointment = {
            id: result.insertId, 
            fullName,
            email,
            phone: phone || '',
            date,
            time,
            message: message || '',
            status: 'Pending',
            createdAt: new Date().toISOString() // Provide a consistent createdAt for response
        };

        console.log('✅ New appointment booked:', newAppointment);
        // Respond with 201 Created status for successful resource creation
        res.status(201).json({
            message: 'Appointment booked successfully!',
            appointment: newAppointment
        });
    } catch (error) {
        console.error('❌ Appointment booking error:', error);
        res.status(500).json({ message: 'Server error during appointment booking.' });
    }
});

// 2. Doctor Login
// CHANGE: This endpoint now authenticates doctors against the 'users' table in MySQL,
// comparing the provided password with the stored hashed password using bcrypt.
app.post('/api/doctor-login', async (req, res) => { // Added 'async'
    const { username, password } = req.body;

    // Basic input validation
    if (!username || !password) {
        return res.status(400).json({ message: 'Username and password are required.' });
    }

    try {
        // Query the 'users' table to find the user by username
        // The [rows] syntax is for array destructuring, as pool.execute returns [rows, fields]
        const [rows] = await pool.execute('SELECT * FROM users WHERE username = ?', [username]);

        // If no user with that username is found
        if (rows.length === 0) {
            return res.status(401).json({ message: 'Invalid username or password.' });
        }

        const user = rows[0]; // Get the first (and only) user found

        // Compare the provided plain-text password with the hashed password from the database
        const isMatch = await bcrypt.compare(password, user.password);

        // If passwords don't match
        if (!isMatch) {
            return res.status(401).json({ message: 'Invalid username or password.' });
        }

        // Authentication successful!
        // TODO: In a real application, you would generate a JWT (JSON Web Token) here
        // and send it back to the client for secure session management.
        // For this demo, we send a mock token.
        res.status(200).json({ message: 'Login successful!', token: 'mock-jwt-token-replace-with-real-jwt' });

    } catch (error) {
        console.error('❌ Doctor login error:', error);
        res.status(500).json({ message: 'Server error during login.' });
    }
});

// 3. Get All Appointments (for doctor console)
// CHANGE: This endpoint now fetches all appointments directly from the MySQL 'appointments' table.
app.get('/api/appointments', async (req, res) => { // Added 'async'
    // TODO: In a real app, you would add JWT authentication here
    // to ensure only logged-in doctors can access this data.
    try {
        // Execute an SQL SELECT statement to retrieve all appointments, ordered by creation time
        const [rows] = await pool.execute('SELECT * FROM appointments ORDER BY createdAt DESC');
        res.status(200).json(rows); // Send the retrieved rows (appointments) as JSON
    } catch (error) {
        console.error('❌ Error fetching appointments:', error);
        res.status(500).json({ message: 'Server error fetching appointments.' });
    }
});

// --- 9. Start the Server ---
app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});
